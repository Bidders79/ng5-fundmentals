<h1>
  Angular Notes
</h1>


<p>Inline templates - intellisense 
    <br/>  
npm install -g angular2-inline
</p>

<br/>
 - Reusing Components with Content Projection
 <br/>
 Content Projection
  Session-list.component.ts
    > Common > collapsable-well
    > ng-content - 
      this is used to display the html content from the calling component
      [well-title]
      [well-body]
  Forms: 
  
Multi field validator

Create a directive
<ul>
  <li>import FormGroup Validator and NG_VALIDATORS </li>
  <li>add a selector that will be use by the html element e.g div </li>
  <li>implement validator and validate method </li>
  <li>assign form controls to variables to </li>
  <li>use type formGroup.root.controls 'control name' to get controls not inside the selector passed in html </li>
  <li> valdaate controls and return null (pass) or selector name with a false value validateLocation:false </li>
  <li>add a local variable to the ngModelGroup #locationGroup="ngModelGroup" so we have access to the return value</li>
  <li>use the reference (locatioGroup) to to check for validation and if control has been touched</li>
  <li>controls can also be accessed through the reference updateValueAndValidity and all its children</li>
</ul>








  <ul>
    <li><strong>Model</strong>
      Also known as Reactive forms and allows you to put logic in the component
      import FormsModule (this contains ngModel and ReativeFormsModule
      Declare a variable FormGroup and OnInit populate it with FormControls that match the html
      Assign the formGroup to the form tag in the html and the controls to the assocated input fields
    </li>
    <li><strong>Template</strong> - built in html- ok for simple forms, 
      <ul>
        <li>Limitations ends up containing alot of complex logic</li>
        <li>Can't unit test</li>
        <li>Cross field validation is nore difficult</li>
      </ul>
    </li>
  </ul>
 <p>Both types of forms handle nested groups of fields. Say we have a model field with its own nested fields {event, name, date, location{address, country }}.
   then ngModelGroup can be used to wrap the corresponding forms fields into a block to pass back to the component.
   
 </p>

  Banana in a box, this specifies two way binding - [()]

    the () specifies html to component binding direction used for responding to events
    the [] specifies component to html binding direction used for displaying data from the component onto the page

    <h1>imported from Forms Module</h1>
    (ngModel) - one way binding - requires a name property which usually matches the model field name to be updated

    Defining a local variable within html used for form creations - #loginForm="ngForm"

    this works the same for both type of forms
    on a form submit we can use (submit)="login(loginForm.value)" 
      a better option is to use the built in ngSubmit, this has more features 
      passing our local form (values only) variable into a method defined in the component
      i.e not submitting the form on validation errors

  
  <h2>Providers</h2>

  In modules where providers for services and varaiables are registered for DI, 
  if they are required across multiple modules then they only need to be registerd in the first module.
  Providers are shared, where as imports and declarations need to included per module as required.


  <h2>Multiple Slot Content Projection</h2>
  This can be used when different sections of content require manipulation, 
  e.g showing and hiding body content on a user click
  <ul>
    <li>Create component to render the html content</li>
    <li>Wrap the html to render in the new component selector tag</li>
    <li>Add div attributes to the html section slots e.g "div well-title"</li>
    <li>Add attributes seletore to the new component, 
      ng-content select="[well-title] to output content where required</li>
  </ul>


  <h2>Object Idenetity</h2>
 Different objetcs, if compared they will equal false
  "var a = object
  "var b = object

  if a new object points to 'a', when compared they will equal true as they point to the same object
  var c = a 
  

  if the object 'a' is mutated, then 'c' still matches as it still points to 'a'
  a.var1 = 3

  if 'a' is assigned to a new object again then 'c' no longer matches
  a = object

Mutability

Objects and arrays are mutable, they can change any time without changing their identity
arrays are just objects

Pipes - In angular 1 impuire pipes were used, which isn't very efficent and can casue performsnce issues

In angular 2 it is recomended to do it in the component, and this is where the data is updated.
The 


<h1>RxJS</h1>
http 

promises - single value in the future
Observables - 0 or more values in the future - sync or async
              any value that changes over time - mouse click x or y position by map

RxJS is packages seperatly > seperate http request - 200+ request to get them all - toPromise() can be used for http:// (one request)



